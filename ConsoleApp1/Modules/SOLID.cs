using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1.Modules
{
    // S — Single responsibility principle
    // O — Open/closed principle
    // L — Liskov substitution principle
    // I — Interface segregation principle
    // D - Dependency inversion principle
    class SOLID
    {
        ////// SINGLE - класс или подобная структура в вашем коде должна отвечать только за одну цель.
        // 1. нарушает при смешивании в одном классе функциональности 2. наличие в классе или его методах абсолютно несвязанного между собой функционала
        // Решение: A - Наш класс не должен быть похож на швейцарский нож, AddEmpoyee, GenerateReport - вынести в разные классы
        // B - Создать интерфейс IPrint, Print вынести в отдельный класс (вызывать принт в текущем через интерфейс) в классе репорт Print(IPrinter printer) 

        ////// O - Объяснение: Главной концепцией данного принципа является то, что класс должен быть открыт для расширений,  но закрыт от модификаций
        // Решение: (base virtual + children override) 
        public void GenerateReport(string type) // csv, pdf, rtf
        {
            if (type == "CSV") { } // Генерация отчета в формате CSV
            if (type == "PDF") { } // Генерация отчета в формате PDF
                
        }
        // создать базовый класс
        // public class EmployeeCSVReport : IEmployeeReport { } //public class EmployeePDFReport : IEmployeeReport
        public virtual void GenerateReport(object em)
        {
            // Базовая реализация, которую нельзя модифицировать
        }

        ////// L вы должны иметь возможность использовать любой производный класс вместо родительского класса 
        // и вести себя с ним таким же образом без внесения изменений
        // Объяснение: (Должна быть возможность вместо базового типа подставить любой его подтип)
        // Прямоугольник -базовый, квадрат -производный, мы передаем только height
        // Решение: abstract с двумя методами переделать на 2 интерфейса

        ////// I - что клиенты не должны принудительно внедрять интерфейсы, которые они не используют.
        
        ////// D - Принцип Инверсии Зависимостей
        //1.классы высокого уровня не должны зависеть от низкоуровневых классов.Оба должны зависеть от абстракций.
        //2.Абстракции не должны зависеть от деталей. Но детали должны зависеть от абстракций.
        // Легко тестируются модифицируются обновляются, конструктор инжекшин
    }
}
